#!/usr/bin/python3
# Figuring out the most common subsets is a hard problem.
# But I was able to hack/use this to find one subset of 5 that appeared 80 times.
# As well as a subset of 9 that appeared 20 times.
# So it does work :D. This saved me 972 bytes. I just tried for johto tms, could try for kanto ones too.

from itertools import combinations # to get subsets
from collections import Counter # To keep counts of subset repeats
import random          # random sample if list is to big
import sys             # stderr log and stdin
import signal          # For giving the subset function a timeout
import time            # For giving the subset function a timeout
import multiprocessing # For giving the subset function a timeout
from concurrent.futures import ThreadPoolExecutor
import math # For how many subsets of len x in thing

def log(*args):
  print(*args)
  print(*args, file=sys.stderr)

# This will return all subsets of a list if possible.
def get_subsets_with_len(subset_len, source_len, l): # only returns up to 100 subsets, but randomly distributed
  subsets = [frozenset(subset) for subset in combinations(random.sample(l, min(len(l), source_len)), subset_len)]
  return random.sample(subsets, min(len(subsets), 200))

def get_subsets(executor, subset_len, l):
  subs = []
  source_len = len(l)-1
  for source_len in range(len(l), subset_len-1, -1):
    if math.comb(source_len,subset_len) <= 10000:
      subs = get_subsets_with_len(subset_len, source_len, l)
      break

  return subs

def get_all_subsets(executor, l):
  all_subs = []
  for subset_len in range(4,len(l)):
    all_subs.append(get_subsets(executor, subset_len, l))
  return all_subs

def main(executor, lists):
  shared_subs = {}
  sub_groups = []

  print("Running in parallel...")

  futures = []
  for i, l in enumerate(lists):
    future = executor.submit(get_all_subsets, executor, l)
    futures.append(future)
    print(f"Starting: {i+1} of {len(lists)}")

  for i, future in enumerate(futures):
    sub_groups.append(future.result())
    print(f"Finished: {i+1} of {len(lists)}")

  # for s, c in Counter(all_subs).items():
  #   if c >= 10:
  #     log("count", c, sorted(list(s)))

if __name__ == "__main__":
  # Pass in lines with numbers separated by spaces.
  lines = [line.split(" ") for line in sys.stdin.read().split("\n")]
  lines = [[y for y in line if y != ""] for line in lines]
  lines = [line for line in lines if len(line) > 0]

  with ThreadPoolExecutor(max_workers=16) as executor:
    main(executor, lines)
